<?php
/**
 * Gearbox - Twig Extension
 *
 * Some new twig filters to help manipulate
 * strings of HTML (typically generated by Redactor fields).
 *
 * Including:
 * ------------------------------------------------------
 * - Remove / extract leading headers (h1,h2,h3,etc)
 * - Remove / extract trailing buttons (a.button)
 * - Remove / extract div.eyebrow elements
 * - Wrap side-by-side buttons in a <p> with p.button-group
 *
 */

namespace modules\gearbox\twigextensions;

use modules\gearbox\Gearbox;

use Craft;
use craft\helpers\StringHelper;
use craft\elements\Entry;
use craft\elements\db\EntryQuery;

use Twig\TwigFilter;
use Twig\TwigFunction;
use Twig\Extension\AbstractExtension;

use Embed\Embed;
use mmikkel\retcon\Retcon;

class GearboxTwigExtension extends AbstractExtension
{

    public function getName(): string
    {
        return 'Gearbox';
    }

    public function getFilters(): array
    {
        return [
            new TwigFilter( 'decode_entities',  [$this, 'decodeEntities']),
            new TwigFilter( 'hex2rgb',          [$this, 'hex2rgb'       ]),
            new TwigFilter( 'ucfirst',          [$this, 'ucFirstFilter' ]),
        ];
    }

    public function getFunctions(): array
    {
        return [
            new TwigFunction('processRichHtml',       [$this, 'processRichHtml']),
            new TwigFunction('hex2rgb',               [$this, 'hex2rgb'        ]),
            new TwigFunction('hex2text',              [$this, 'hex2text'       ]),
            new TwigFunction('embedInfo',             [$this, 'embedInfo'      ]),

            new TwigFunction('getContentFeedQuery',   [$this, 'getContentFeedQuery'   ]),
            new TwigFunction('getContentFeedResults', [$this, 'getContentFeedResults' ]),
        ];
    }


    public function ucFirstFilter(string|null $val)
    {
        return ucfirst($val);
    }

    public function getContentFeedQuery( $feedID, $settings ): EntryQuery
    {
        // Get the feeds entry
        $feeds = Entry::find()->section('taxonomy')->id( $feedID ) ?? null;
        $firstFeed = $feeds->one() ?? null;

        // Collect query parameters
        $filter = Craft::$app->request->getParam('f') ?? $settings['filter'] ?? $firstFeed->slug ?? null;
        $query  = Craft::$app->request->getParam('q') ?? $settings['query'] ?? null;

        // Get the search entry
        $search = $feeds->collect()->firstWhere('slug', $filter) ?? $firstFeed ?? null;

        // Get content type, section, and entry type
        $contentType = $search ? $search->contentType->reference() : null;
        $section     = $contentType ? ( $contentType['section']   ?? null ) : null;
        $entryType   = $contentType ? ( $contentType['entryType'] ?? null ) : null;

        // Get sort, redirect, and topics
        $sort     = $search ? $search->sort->value : null;
        $topics   = $search ? $search->taxonomies->all() : null;

        // Set search/sort/filter settings
        $orderBy = 'postDate DESC';
        $orderBy = $sort == 'random' ? 'RAND()' : $orderBy;
        $orderBy = $sort == 'alphabetical' ? 'title DESC' : $orderBy;
        $orderBy = $sort == 'upcoming' ? 'startDate ASC' : $orderBy;

        // Create the starting query
        $collectionQuery = null;
        if ($section == 'products') {
            $collectionQuery = Entry::find()->section('products')->availableForPurchase(true);
            $orderBy = $sort == 'recent' ? 'dateUpdated DESC' : $orderBy;
        } else {
            $collectionQuery = Entry::find();
            $collectionQuery = $section ? $collectionQuery->section($section) : $collectionQuery;
        }

        if ($query) {
            $collectionQuery = $collectionQuery->search($query);
            $orderBy = 'score';
        }

        $limit = $settings['limit'] ?? 3;
        $collectionQuery = $collectionQuery->orderBy($orderBy)->limit( $limit );

        if( $entryType ) {
            $collectionQuery = $collectionQuery->type( $entryType );
        }

        if( $topics ) {
            $collectionQuery = $collectionQuery->relatedTo( $topics );
        }

        return $collectionQuery;
    }


    public function getContentFeedResults( $feedID, $settings ): Array
    {
        return $this->getContentFeedQuery( $feedID, $settings )->all() ?? [];
    }


    public function processRichHtml( string|null $html = "" ): array
    {
        // selector configs
        // TODO: move these into a config file
        $settings = [
            'eyebrowSelector'     => "div.eyebrow:first-child",
            'headlineSelectors'   => ['h1:first-child','h2:first-child','h3:first-child'],
            'defaultMarkSelector' => "mark:not(.m1):not(.m2)",
            'defaultMarkClass'    => "m1",
            'markSelectors'       => ['mark.m1','mark.m2'],
            'ctaSelector'         => "a.button",
            'lastSmallSelector'   => "p.small:last-child",
            'trailingCtaSelector' => "p[data-has-buttons]:last-child",
            'figureClassPrefix'   => "imageCard",
        ];


        // keep a copy of the original unchanged text body
        $processed = $html;
        $textParts = [
            'original'  => $html,
            'eyebrow'   => null,
            'headline'  => null,
            'cta'       => null,
            'body'      => null,
            'oAlign'    => null,
        ];

        if( !$html ) {
            return $textParts;
        }

        // do some retcon things that we want to do for all text fields
        $processed = $this->commonTextManipulations( $processed, $settings );

        // if the html string only has a single link element in the entire block
        $links = $this->retconOnly( $processed, "a" );
        if( mb_substr_count( mb_strtolower( $links ), "</a>" ) == 1 ) {
            $processed = (string) Retcon::getInstance()->retcon->attr( $processed, "a", [ "data-only-link" => true ] );
        }

        // process the top level DomElements in the rich html string for:
        //  - embedded rich media (images, videos, url strings, etc)
        //  - replace style="text-align:left|center|right" attriutes with class names
        //  - paragraphs that contain one or more buttons
        $processed = $this->processTopLevelDomElements( $processed, $settings );

        // extract the div.eyebrow element appearing before any other element in the html string
        $textParts['eyebrow'] = $this->retconOnly( $processed, $settings['eyebrowSelector'] );
        $processed = $this->retconRemove( $processed, $settings['eyebrowSelector'] );

        // find the alignment of the opening element
        if( $textParts['oAlign'] = $this->openingBlockAlignment( $processed, $settings ) ) {
            $mx = "mr-auto";
            $mx = 'center' == $textParts['oAlign'] ? 'mx-auto' : $mx;
            $mx = 'right'  == $textParts['oAlign'] ? 'ml-auto' : $mx;
            $textParts['eyebrow'] = (string) Retcon::getInstance()->retcon->attr(
                $textParts['eyebrow'],
                '.eyebrow',
                [ 'class' => $mx ],
                false                   // overwrite
            );
        }

        // TODO: automatically add id to eyebrow
        // {% set eyebrowText = ( eyebrow ?? '' )|striptags|trim|lower|ascii|kebab  %}
        // {% if eyebrowText %}
        //     {% set eyebrow = eyebrow|retconAttr( 'div', { id: eyebrowText }) %}
        // {% endif %}

        // do the same for h1,h2,h3 elements in cascading succession
        foreach( $settings['headlineSelectors'] as $headerTagSelector ) {
            $textParts['headline'] .= $this->retconOnly( $processed, $headerTagSelector );
            $processed = $this->retconRemove( $processed, $headerTagSelector );
        }

        // find any small/micetype paragraphs at the bottom of the html string
        // these sometimes site below trailing buttons and should be extracted with it
        $lastSmallPara = $this->retconOnly( $processed, $settings['lastSmallSelector'] );
        $processed = $this->retconRemove( $processed, $settings['lastSmallSelector'] );

        // grab the last paragraph and test to see if it contains buttons. or more specifically,
        // test if the first child of last paragraph is a link of some kind (typically a call-to-action)
        $lastButtonPara = $this->retconOnly( $processed, $settings['trailingCtaSelector'] );
        $processed = $this->retconRemove( $processed, $settings['trailingCtaSelector'] );

        // if we found a trailing button paragraph, save it separately with the last small paragraph (if any).
        // otherwise, slap push any last small paragraph element on to the bottom of the processed html string
        if( $lastButtonPara ) {
            $textParts['cta'] = $lastButtonPara . $lastSmallPara;
        } else {
            $processed .= $lastSmallPara;
        }

        $processed = $this->processTopLevelDomElements( $processed, $settings );

        $textParts['body'] = $processed;
        // $textParts['bodyRaw'] = (string) Retcon::getInstance()->retcon->change(
        //     $processed,
        //     ['h1','h2','h3','h4','h5','h6','p','li','ul','ol','div'],
        //     false
        // );

        return $textParts;
    }


    private function retconOnly( $html, $selector ) {
        $html = (string) Retcon::getInstance()->retcon->only( "<template>$html</template>", "template $selector" ) ?? null;
        return trim( $html );
    }


    private function retconAttr( $html, $selector, $attr, $overwrite = true ) {
        $html = (string) Retcon::getInstance()->retcon->attr( $html, $selector, $attr, $overwrite ) ?? null;
        return trim( $html );
    }

    private function retconRemove( $html, $selector ) {
        $html = (string) Retcon::getInstance()->retcon->remove( "<template>$html</template>", "template $selector" );
        $html = (string) Retcon::getInstance()->retcon->change( $html, "template", false );
        return trim( $html );
    }


    private function commonTextManipulations( $html, $settings = [] )
    {
        // add a base class to all block level elements to identify them as
        // having come from redactor so that they can be easily styled
        $html = (string) Retcon::getInstance()->retcon->attr(
            $html,
            "p,ol,ul,blockquote,h1,h2,h3,h4,h5,h6,hr",
            ["class" => "html"], false
        );

        // duplicate all href attributes to data-href inside <a> elements
        $html = (string) Retcon::getInstance()->retcon->renameAttr( $html, "a", [ 'href' => 'data-ahref' ] );
        $html = preg_replace('/data-ahref="(.*?)"/', "href=\"$1\" data-ahref=\"$1\"", $html );

        // make sure all <mark> elements have a default class
        $html = (string) Retcon::getInstance()->retcon->attr(
            $html,
            $settings['defaultMarkSelector'],
            ["class" => $settings['defaultMarkClass'] ]
        );

        // backflip our way into wrapping the inner contents of all <mark> elements with a plain <span>
        foreach( $settings['markSelectors'] as $markTagSelector ) {
            $html = (string) Retcon::getInstance()->retcon->wrap( $html, $markTagSelector, $markTagSelector );
            $html = (string) Retcon::getInstance()->retcon->change( $html, "$markTagSelector $markTagSelector", "span" );
            $html = (string) Retcon::getInstance()->retcon->attr( $html, "$markTagSelector span", [ "class" => null ] );
        }

        return $html;
    }


    private function processTopLevelDomElements( $html, $settings ) {

        if( $nodes = $this->_html2nodes( $html ) ) {
            $html = "";
            foreach( $nodes AS $node ) {
                if( $node ) {

                    $node = $this->setNodeAlignment( $node, $settings );

                    $nodeHtml = "";
                    switch( mb_strtolower( $node->tagName ?? "" ) ) {
                        case 'figure':
                            $nodeHtml = $this->generateFigureHtml( $node, $settings['figureClassPrefix'] ?? null );
                            break;
                        case 'p':
                            $nodeHtml = $this->generateParagraphHtml( $node, $settings['ctaSelector'] ?? null );
                            break;
                        default:
                            $nodeHtml = $node->ownerDocument->saveHTML($node);
                    }

                    $html .= $nodeHtml;
                }
            }
        }

        return $html;
    }


    private function openingBlockAlignment( $html, $settings ) {

        $classLeft   = $settings["classLeft"]   ?? "text-left";
        $classCenter = $settings["classCenter"] ?? "text-center";
        $classRight  = $settings["classRight"]  ?? "text-right";

        if( $nodes = $this->_html2nodes( $html ) ) {
            foreach ( $nodes as $key => $node) {
                $class = $node->getAttribute('class') ?? '';
                if( mb_strstr( $class, 'eyebrow' ) ) { continue; }
                foreach( [$classLeft,$classCenter,$classRight] AS $align ) {
                    if( mb_strstr( $class, $align ) ) {
                        if( $align == $classLeft   ) { return 'left';   }
                        if( $align == $classCenter ) { return 'center'; }
                        if( $align == $classRight  ) { return 'right';  }
                    }
                }
                return null;
            }
        }

        return null;
    }


    private function generateFigureHtml( $node, $figureClassPrefix )
    {
        $view = Craft::$app->getView();
        $templateMode = $view->getTemplateMode();
        $view->setTemplateMode($view::TEMPLATE_MODE_SITE);

        $figureHtml   = $node->ownerDocument->saveHTML( $node );
        $figureClass  = $node->getAttribute('class') ?? "";
        $cardTemplate = mb_ereg_replace( $figureClassPrefix, '', $figureClass );

        // TODO: Clean-up this dumb ugly bullshit
        // ------------------------------------------------------------------------
        $figureLink     = $this->retconOnly( $figureHtml, "a" );
        $figureImage    = $this->retconOnly( $figureHtml, "img" );
        $figureIframe   = $this->retconOnly( $figureHtml, "iframe" );
        $figureCaption  = $this->retconOnly( $figureHtml, "figcaption" );
        $linkNodes      = $this->_html2nodes( $figureLink   ) ?? [];
        $imageNodes     = $this->_html2nodes( $figureImage  ) ?? [];
        $iframeNodes    = $this->_html2nodes( $figureIframe ) ?? [];
        $linkNode       = null;
        $imageNode      = null;
        $iframeNode     = null;
        foreach( $linkNodes AS $node   ) { $linkNode   = $node; break; }
        foreach( $imageNodes AS $node  ) { $imageNode  = $node; break; }
        foreach( $iframeNodes AS $node ) { $iframeNode = $node; break; }
        // ------------------------------------------------------------------------

        $cleanCardTmplName = trim( mb_ereg_replace('/[^\w\d\-\_]+/', '', $cardTemplate ) ) ?? 'basic';
        $cardComponentPath = $iframeNode
            ? "_cards/media/"
            : "_cards/image/";

        $cardTwigInclude   = '{% include "' . $cardComponentPath . $cleanCardTmplName . '" ignore missing %}';

        $cardSettings = [
            'figureID'     => $node->getAttribute('id') ?? StringHelper::UUID(),
            'link'         => $linkNode  ? $linkNode->getAttribute('href') ?? null : null,
            'image'        => $imageNode ? $imageNode->getAttribute('src') ?? null : null,
            'altText'      => $imageNode ? $imageNode->getAttribute('alt') ?? $imageNode->getAttribute('title') ?? null : null,
            'imageCaption' => (string) Retcon::getInstance()->retcon->change( $figureCaption, "figcaption", false ) ?? ""
        ];

        $newFigureHtml = (string) $view->renderString( $cardTwigInclude, [ 'settings' => $cardSettings ] );

        $view->setTemplateMode($templateMode);

        return trim( $newFigureHtml ?? $figureHtml );
    }


    // convert:
    //   style="text-align:left/center/right"
    // to:
    //   class="text-left/text-center/text-right"
    private function setNodeAlignment( $node, $settings )
    {
        $classLeft   = $settings["classLeft"]   ?? "text-left";
        $classCenter = $settings["classCenter"] ?? "text-center";
        $classRight  = $settings["classRight"]  ?? "text-right";

        $nodeStyle = $node->getAttribute('style') ?? "";
        $nodeClass = $node->getAttribute('class') ?? "";
        $nodeStyle = mb_strtolower( mb_ereg_replace( ' ', '', $nodeStyle ) );

        if( strstr( $nodeStyle, "text-align:left" ) ) {
            $node->setAttribute( "class", implode( " ", [$nodeClass, $classLeft] ) );
        }

        if( strstr( $nodeStyle, "text-align:center" ) ) {
            $node->setAttribute( "class", implode( " ", [$nodeClass, $classCenter] ) );
        }

        if( strstr( $nodeStyle, "text-align:right" ) ) {
            $node->setAttribute( "class", implode( " ", [$nodeClass, $classRight] ) );
        }

        // clean up the style tag
        $nodeStyle = mb_ereg_replace( 'text-align:left',   '', $nodeStyle );
        $nodeStyle = mb_ereg_replace( 'text-align:center', '', $nodeStyle );
        $nodeStyle = mb_ereg_replace( 'text-align:right',  '', $nodeStyle );

        empty( $nodeStyle )
            ? $node->removeAttribute( "style" )
            : $node->setAttribute( "style", $nodeStyle );

        return $node;
    }


    private function generateParagraphHtml( $node, $ctaSelector )
    {
        $paraHtml = $node->ownerDocument->saveHTML( $node );

        if( $this->retconOnly( $paraHtml, $ctaSelector ) ) {
            $paraHtml = (string) Retcon::getInstance()->retcon->attr( $paraHtml, 'p', ['data-has-buttons' => true] );
        }

        return trim( $paraHtml );
    }


    private function _html2nodes( $html )
    {
        $html = \mb_convert_encoding($html, 'HTML-ENTITIES', Craft::$app->getView()->getTwig()->getCharset());
        if( mb_substr($html,0,1) != '<' ) {
            return null;
        }

        $libxmlUseInternalErrors = \libxml_use_internal_errors(true);
        $doc = new \DOMDocument();
        $doc->loadHTML("<template>$html</template>", LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        \libxml_use_internal_errors($libxmlUseInternalErrors);

        $crawler = new \Symfony\Component\DomCrawler\Crawler($doc);
        return $crawler->filter('template')->children();
    }


    public function decodeEntities( string|null $html = "" ): string
    {
        return html_entity_decode( $html );
    }


    public function embedInfo( $url )
    {
        $embedData = \Craft::$app->cache->getOrSet( "oembed2-$url", function () use ($url) {
            $embed = new Embed();
            $info = $embed->get($url);

            $data = [
                'title'       => $info->title,
                'summary'     => $info->description,
                'url'         => (string) $info->url,
                'images'      => [ ['url' => (string) $info->image] ],
                'html'        => $info->code->html,
                'ratio'       => $info->code->ratio,
                'aspect'      => "",
                'provider'    => mb_strtolower( $info->providerName ),
                'authorName'  => $info->authorName ?? null,
                'authorUrl'   => $info->authorUrl  ?? null,
            ];

            if( (int) $data['ratio'] == 56 ) {
                $data['aspect'] = "aspect-video";
            }

            $data['html'] = (string) Retcon::getInstance()->retcon->attr( $data['html'], "blockquote.twitter-tweet", [
                'class' => 'mx-auto'
            ], false );

            $data['html'] = (string) Retcon::getInstance()->retcon->attr( $data['html'], "iframe", [
                'class' => $data['aspect'],
                'height' => '100%',
                'width' => '100%'
            ], true );

            return $data;

        }, 86400 );

        return $embedData;
    }


    public function hex2rgb( $colour )
    {
        $colour = ltrim( $colour, '#' );

        if( strlen( $colour ) == 6 ) {
            list( $r, $g, $b ) = array( $colour[0] . $colour[1], $colour[2] . $colour[3], $colour[4] . $colour[5] );
        } elseif ( strlen( $colour ) == 3 ) {
            list( $r, $g, $b ) = array( $colour[0] . $colour[0], $colour[1] . $colour[1], $colour[2] . $colour[2] );
        } else {
            return false;
        }

        $r = hexdec( $r );
        $g = hexdec( $g );
        $b = hexdec( $b );

        return "$r,$g,$b";
    }


    // figure out whether black or white is the most appropriate colour
    // to use for displaying text over top of a given background hex value
    public function hex2text( $hex ) {

        // Convert hex code to an array of RGB values
        list($r, $g, $b) = sscanf($hex, "#%02x%02x%02x");

        // Convert RGB values to decimal
        $decimal_r = intval($r, 16);
        $decimal_g = intval($g, 16);
        $decimal_b = intval($b, 16);

        // Apply formula to determine text color
        $luminance = $decimal_r * 0.299 + $decimal_g * 0.587 + $decimal_b * 0.114;

        // Use #000000 for text color if luminance is greater than 186
        return ($luminance > 156) ? '#000000' : '#ffffff';
    }
}
