<?php
/**
 * Gearbox - Twig Extension
 *
 * Some new twig filters to help manipulate
 * strings of HTML (typically generated by Redactor fields).
 *
 * Including:
 * ------------------------------------------------------
 * - Remove / extract leading headers (h1,h2,h3,etc)
 * - Remove / extract trailing buttons (a.button)
 * - Remove / extract div.eyebrow elements
 * - Wrap side-by-side buttons in a <p> with p.button-group
 *
 */

namespace modules\gearbox\twigextensions;

use modules\gearbox\Gearbox;

use Craft;
use craft\helpers\StringHelper;

use Twig\TwigFilter;
use Twig\TwigFunction;
use Twig\TwigMarkup;
use Twig\Extension\AbstractExtension;

use Embed\Embed;
use mmikkel\retcon\Retcon;

class GearboxTwigExtension extends AbstractExtension
{

    public function getName(): string
    {
        return 'Gearbox';
    }

    public function getFilters(): array
    {
        return [
            new TwigFilter( 'decode_entities',  [$this, 'decodeEntities']),
            new TwigFilter( 'hex2rgb',          [$this, 'hex2rgb'       ]),
            new TwigFilter( 'ucfirst',          [$this, 'ucFirstFilter' ]),
        ];
    }

    public function getFunctions(): array
    {
        return [
            // new TwigFunction('leadingHeaders',  [$this, 'leadingHeaders']),
            // new TwigFunction('trailingButtons', [$this, 'trailingButtons']),

            new TwigFunction('processRichHtml', [$this, 'processRichHtml'   ]),
            new TwigFunction('hex2rgb',         [$this, 'hex2rgb'           ]),
            new TwigFunction('hex2text',        [$this, 'hex2text'          ]),
            new TwigFunction('embedInfo',       [$this, 'embedInfo'         ]),
        ];
    }

    public function ucFirstFilter(string|null $val)
    {
        return ucfirst($val);
    }

    public function processRichHtml( string|null $html = "" ): array
    {
        // selector configs
        // TODO: move these into a config file
        $settings = [
            'eyebrowSelector'     => "div.eyebrow:first-child",
            'headlineSelectors'   => ['h1:first-child','h2:first-child','h3:first-child'],
            'defaultMarkSelector' => "mark:not(.m1):not(.m2)",
            'defaultMarkClass'    => "m1",
            'markSelectors'       => ['mark.m1','mark.m2'],
            'ctaSelector'         => "a.button",
            'lastSmallSelector'   => "p.small:last-child",
            'trailingCtaSelector' => "p[data-has-buttons]:last-child",
            'figureClassPrefix'   => "cImageCard__",
        ];


        // keep a copy of the original unchanged text body
        $processed = $html;
        $textParts = [
            'original'  => $html,
            'eyebrow'   => null,
            'headline'  => null,
            'cta'       => null,
            'body'      => null,
        ];

        if( !$html ) {
            return $textParts;
        }

        // do some retcon things that we want to do for all text fields
        $processed = $this->commonTextManipulations( $processed, $settings );

        // if the html string only has a single link element in the entire block
        $links = $this->retconOnly( $processed, "a" );
        if( mb_substr_count( mb_strtolower( $links ), "</a>" ) == 1 ) {
            $processed = (string) Retcon::getInstance()->retcon->attr( $processed, "a", [ "data-only-link" => true ] );
        }

        // process the top level DomElements in the rich html string for:
        //  - embedded rich media (images, videos, url strings, etc)
        //  - replace style="text-align:left|center|right" attriutes with class names
        //  - paragraphs that contain one or more buttons
        $processed = $this->processTopLevelDomElements( $processed, $settings );

        // extract the div.eyebrow element appearing before any other element in the html string
        $textParts['eyebrow'] = $this->retconOnly( $processed, $settings['eyebrowSelector'] );
        $processed = $this->retconRemove( $processed, $settings['eyebrowSelector'] );

        // TODO: automatically add id to eyebrow
        // {% set eyebrowText = ( eyebrow ?? '' )|striptags|trim|lower|ascii|kebab  %}
        // {% if eyebrowText %}
        //     {% set eyebrow = eyebrow|retconAttr( 'div', { id: eyebrowText }) %}
        // {% endif %}

        // do the same for h1,h2,h3 elements in cascading succession
        foreach( $settings['headlineSelectors'] as $headerTagSelector ) {
            $textParts['headline'] .= $this->retconOnly( $processed, $headerTagSelector );
            $processed = $this->retconRemove( $processed, $headerTagSelector );
        }

        // find any small/micetype paragraphs at the bottom of the html string
        // these sometimes site below trailing buttons and should be extracted with it
        $lastSmallPara = $this->retconOnly( $processed, $settings['lastSmallSelector'] );
        $processed = $this->retconRemove( $processed, $settings['lastSmallSelector'] );

        // grab the last paragraph and test to see if it contains buttons. or more specifically,
        // test if the first child of last paragraph is a link of some kind (typically a call-to-action)
        $lastButtonPara = $this->retconOnly( $processed, $settings['trailingCtaSelector'] );
        $processed = $this->retconRemove( $processed, $settings['trailingCtaSelector'] );

        // if we found a trailing button paragraph, save it separately with the last small paragraph (if any).
        // otherwise, slap push any last small paragraph element on to the bottom of the processed html string
        if( $lastButtonPara ) {
            $textParts['cta'] = $lastButtonPara . $lastSmallPara;
        } else {
            $processed .= $lastSmallPara;
        }

        $textParts['body'] = $processed;
        // $textParts['bodyRaw'] = (string) Retcon::getInstance()->retcon->change(
        //     $processed,
        //     ['h1','h2','h3','h4','h5','h6','p','li','ul','ol','div'],
        //     false
        // );

        return $textParts;
    }


    private function retconOnly( $html, $selector ) {
        $html = (string) Retcon::getInstance()->retcon->only( "<wrapper>$html</wrapper>", "wrapper $selector" ) ?? null;
        return trim( $html );
    }


    private function retconRemove( $html, $selector ) {
        $html = (string) Retcon::getInstance()->retcon->remove( "<wrapper>$html</wrapper>", "wrapper $selector" );
        $html = (string) Retcon::getInstance()->retcon->change( $html, "wrapper", false );
        return trim( $html );
    }


    private function commonTextManipulations( $html, $settings = [] )
    {
        // add a base class to all block level elements to identify them as
        // having come from redactor so that they can be easily styled
        $html = (string) Retcon::getInstance()->retcon->attr(
            $html,
            "p,ol,ul,blockquote,h1,h2,h3,h4,h5,h6,hr",
            ["class" => "base"], false
        );

        // duplicate all href attributes to data-href inside <a> elements
        $html = (string) Retcon::getInstance()->retcon->renameAttr( $html, "a", [ 'href' => 'data-ahref' ] );
        $html = preg_replace('/data-ahref="(.*?)"/', "href=\"$1\" data-ahref=\"$1\"", $html );

        // make sure all <mark> elements have a default class
        $html = (string) Retcon::getInstance()->retcon->attr(
            $html,
            $settings['defaultMarkSelector'],
            ["class" => $settings['defaultMarkClass'] ]
        );

        // backflip our way into wrapping the inner contents of all <mark> elements with a plain <span>
        foreach( $settings['markSelectors'] as $markTagSelector ) {
            $html = (string) Retcon::getInstance()->retcon->wrap( $html, $markTagSelector, $markTagSelector );
            $html = (string) Retcon::getInstance()->retcon->change( $html, "$markTagSelector $markTagSelector", "span" );
            $html = (string) Retcon::getInstance()->retcon->attr( $html, "$markTagSelector span", [ "class" => null ] );
        }

        return $html;
    }


    private function processTopLevelDomElements( $html, $settings ) {

        if( $nodes = $this->_html2nodes( $html ) ) {
            $html = "";
            foreach( $nodes AS $node ) {
                if( $node ) {

                    $node = $this->setNodeAlignment( $node, $settings );

                    $nodeHtml = "";
                    switch( mb_strtolower( $node->tagName ?? "" ) ) {
                        case 'figure':
                            $nodeHtml = $this->generateFigureHtml( $node, $settings['figureClassPrefix'] ?? null );
                            break;
                        case 'p':
                            $nodeHtml = $this->generateParagraphHtml( $node, $settings['ctaSelector'] ?? null );
                            break;
                        default:
                            $nodeHtml = $node->ownerDocument->saveHTML($node);
                    }

                    $html .= $nodeHtml;
                }
            }
        }
        return $html;
    }


    private function generateFigureHtml( $node, $figureClassPrefix )
    {
        $view = Craft::$app->getView();
        $templateMode = $view->getTemplateMode();
        $view->setTemplateMode($view::TEMPLATE_MODE_SITE);

        $figureHtml   = $node->ownerDocument->saveHTML( $node );
        $figureClass  = $node->getAttribute('class') ?? "";
        $cardTemplate = mb_ereg_replace( $figureClassPrefix, '', $figureClass );

        // TODO: Clean-up this dumb ugly bullshit
        // ------------------------------------------------------------------------
        $figureLink     = $this->retconOnly( $figureHtml, "a" );
        $figureImage    = $this->retconOnly( $figureHtml, "img" );
        $figureIframe   = $this->retconOnly( $figureHtml, "iframe" );
        $figureCaption  = $this->retconOnly( $figureHtml, "figcaption" );
        $linkNodes      = $this->_html2nodes( $figureLink   ) ?? [];
        $imageNodes     = $this->_html2nodes( $figureImage  ) ?? [];
        $iframeNodes    = $this->_html2nodes( $figureIframe ) ?? [];
        $linkNode       = null;
        $imageNode      = null;
        $iframeNode     = null;
        foreach( $linkNodes AS $node   ) { $linkNode   = $node; break; }
        foreach( $imageNodes AS $node  ) { $imageNode  = $node; break; }
        foreach( $iframeNodes AS $node ) { $iframeNode = $node; break; }
        // ------------------------------------------------------------------------

        $cleanCardTmplName = trim( mb_ereg_replace('/[^\w\d\-\_]+/', '', $cardTemplate ) ) ?? 'basic';
        $cardComponentPath = $iframeNode
            ? "_cards/richmedia/"
            : "_cards/image/";

        $cardTwigInclude   = '{% include "' . $cardComponentPath . $cleanCardTmplName . '" ignore missing %}';

        $cardSettings = [
            'figureID'     => $node->getAttribute('id') ?? StringHelper::UUID(),
            'link'         => $linkNode  ? $linkNode->getAttribute('href') ?? null : null,
            'image'        => $imageNode ? $imageNode->getAttribute('src') ?? null : null,
            'altText'      => $imageNode ? $imageNode->getAttribute('alt') ?? $imageNode->getAttribute('title') ?? null : null,
            'imageCaption' => (string) Retcon::getInstance()->retcon->change( $figureCaption, "figcaption", false ) ?? ""
        ];

        $newFigureHtml = (string) $view->renderString( $cardTwigInclude, [ 'settings' => $cardSettings ] );

        $view->setTemplateMode($templateMode);

        return trim( $newFigureHtml ?? $figureHtml );
    }


    // convert:
    //   style="text-align:left/center/right"
    // to:
    //   class="text-left/text-center/text-right"
    private function setNodeAlignment( $node, $settings )
    {
        $classLeft   = $settings["classLeft"]   ?? "text-left";
        $classCenter = $settings["classCenter"] ?? "text-center";
        $classRight  = $settings["classRight"]  ?? "text-right";

        $nodeStyle = $node->getAttribute('style') ?? "";
        $nodeClass = $node->getAttribute('class') ?? "";
        $nodeStyle = mb_strtolower( mb_ereg_replace( "/\s+/", '', $nodeStyle ) );

        if( strstr( $nodeStyle, "text-align:left" ) ) {
            $node->setAttribute( "class", implode( " ", [$nodeClass, $classLeft] ) );
        }

        if( strstr( $nodeStyle, "text-align:center" ) ) {
            $node->setAttribute( "class", implode( " ", [$nodeClass, $classCenter] ) );
        }

        if( strstr( $nodeStyle, "text-align:right" ) ) {
            $node->setAttribute( "class", implode( " ", [$nodeClass, $classRight] ) );
        }

        return $node;
    }


    private function generateParagraphHtml( $node, $ctaSelector )
    {
        $paraHtml = $node->ownerDocument->saveHTML( $node );

        if( $this->retconOnly( $paraHtml, $ctaSelector ) ) {
            $paraHtml = (string) Retcon::getInstance()->retcon->attr( $paraHtml, 'p', ['data-has-buttons' => true] );
        }

        return trim( $paraHtml );
    }


    private function _html2nodes( $html )
    {
        $html = \mb_convert_encoding($html, 'HTML-ENTITIES', Craft::$app->getView()->getTwig()->getCharset());
        if( mb_substr($html,0,1) != '<' ) {
            return null;
        }

        $libxmlUseInternalErrors = \libxml_use_internal_errors(true);
        $doc = new \DOMDocument();
        $doc->loadHTML("<wrapper>$html</wrapper>", LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        \libxml_use_internal_errors($libxmlUseInternalErrors);

        $crawler = new \Symfony\Component\DomCrawler\Crawler($doc);
        return $crawler->filter('wrapper')->children();
    }


    public function decodeEntities( string|null $html = "" ): string
    {
        return html_entity_decode( $html );
    }


    public function embedInfo( $url )
    {
        $embedData = \Craft::$app->cache->getOrSet( "embedData-$url", function () use ($url) {
            $embed = new Embed();
            $info = $embed->get($url);

            $data = [
                'title'      => $info->title,
                'summary'    => $info->description,
                'url'        => (string) $info->url,
                'images'     => [ ['url' => (string) $info->image] ],
                'html'       => $info->code->html,
                'ratio'      => $info->code->ratio,
                'aspect'     => "",
                'provider'   => mb_strtolower( $info->providerName ),
            ];

            if( (int) $data['ratio'] == 56 ) {
                $data['aspect'] = "aspect-video";
            }

            $data['html'] = (string) Retcon::getInstance()->retcon->attr( $data['html'], "blockquote.twitter-tweet", [
                'class' => 'mx-auto'
            ], false );

            $data['html'] = (string) Retcon::getInstance()->retcon->attr( $data['html'], "iframe", [
                'class' => $data['aspect'],
                'height' => '100%',
                'width' => '100%'
            ], true );

            return $data;

        }, 86400 );

        return $embedData;
    }


    public function hex2rgb( $colour )
    {
        $colour = ltrim( $colour, '#' );

        if( strlen( $colour ) == 6 ) {
            list( $r, $g, $b ) = array( $colour[0] . $colour[1], $colour[2] . $colour[3], $colour[4] . $colour[5] );
        } elseif ( strlen( $colour ) == 3 ) {
            list( $r, $g, $b ) = array( $colour[0] . $colour[0], $colour[1] . $colour[1], $colour[2] . $colour[2] );
        } else {
            return false;
        }

        $r = hexdec( $r );
        $g = hexdec( $g );
        $b = hexdec( $b );

        return "$r,$g,$b";
    }


    // figure out whether black or white is the most appropriate colour
    // to use for displaying text over top of a given background hex value
    public function hex2text( $hex ) {

        // Convert hex code to an array of RGB values
        list($r, $g, $b) = sscanf($hex, "#%02x%02x%02x");

        // Convert RGB values to decimal
        $decimal_r = intval($r, 16);
        $decimal_g = intval($g, 16);
        $decimal_b = intval($b, 16);

        // Apply formula to determine text color
        $luminance = $decimal_r * 0.299 + $decimal_g * 0.587 + $decimal_b * 0.114;

        // Use #000000 for text color if luminance is greater than 186
        return ($luminance > 156) ? '#000000' : '#ffffff';
    }
}
