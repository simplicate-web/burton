<!-- LEAVE THIS HTML COMMENT INTACT - Craft gets angry if there's no HTML content in the twig file-->

{#
    Craft CMS 4 - matrix-conditionals.twig
    https://github.com/simplicate-web/craft4-matrix-conditionals
    Steve Comrie <steve@simplicate.ca>
#}

{% js %}

// Sample configuration
// read more here: https://github.com/simplicate-web/craft4-matrix-conditionals#configuration
// ---------------------------------------------------------------
var matrixConditionalsConfig = {

    // collections block type
    '*.collection.source':
    {
        'entries': {
            showOnEqual: 'entries',
            hideOnUnequal: 'entries',
        },

        'feed': {
            showOnEqual: ['feeds','limit','interface'],
            hideOnUnequal: ['feeds','limit','interface'],
        },

        'assets': {
            showOnEqual: 'assets',
            hideOnUnequal: 'assets',
        },

        'items': {
            showOnEqual: 'items',
            hideOnUnequal: 'items',
        },
    },


    // collections items
    '*.collection.bit':
    {
        ':notempty:': {
            showOnUnequal: ['headline','text','images'],
            hideOnEqual: ['headline','text','images']
        }
    },


    // highlight block type
    '*.highlight.variant':
    {
        'spotlight': {
            showOnEqual: 'entries',
            hideOnUnequal: 'entries',
        },

        'search': {
            showOnEqual: 'feeds',
            hideOnUnequal: 'feeds',
        },

        'form': {
            showOnEqual: 'form',
            hideOnUnequal: 'form',
        },

        'menu': {
            showOnEqual: 'menu',
            hideOnUnequal: 'menu',
        },

        'iframe': {
            showOnEqual: 'code',
            hideOnUnequal: 'code',
        },

        'special': {
            showOnEqual: 'special',
            hideOnUnequal: 'special',
        }
    },


    // media block type
    '*.media.source': {

        'local': {
            showOnEqual: 'assets',
            hideOnUnequal: 'assets',
        },

        'external': {
            showOnEqual: 'embeds',
            hideOnUnequal: 'embeds',
        }
    }
}


if( typeof Craft.MatrixConditionals === 'undefined' ) {
    Craft.MatrixConditionals = {

        findMatchingConditional(value, field, block, matrix) {
            this.currentValue = this.cleanValue( value )

            if( $fullMatch = this.findFieldCondition(`${matrix}.${block}.${field}`) )
                return $fullMatch

            if( $anyMatrixMatch = this.findFieldCondition(`*.${block}.${field}`) )
                return $anyMatrixMatch

            if( $anyBlockMatch = this.findFieldCondition(`${matrix}.*.${field}`) )
                return $anyBlockMatch

            if( $anyField = this.findFieldCondition(`*.*.${field}`) )
                return $anyField
        },

        findFieldCondition( condition ) {
            this.currentCondition = condition
            return this.config[condition] ?? null
        },

        cleanValue(value) {
            if( ! value ?? null ) { return '' }
            var strValue = value.toString().trim().toLowerCase()
            if( strValue.startsWith('base64:') ) {
                strValue = this.decodeBase64( value ).toLowerCase();
            }

            return strValue
        },

        decodeBase64(value) {
            if( ! value ?? null ) { return '' }
            return atob(value.toString().trim().replace('base64:', ''))
        },

        evaluateConditions( block, value, conditions ) {
            const thisObj  = this
            const strValue = this.cleanValue( value )

            Object.keys(conditions).forEach(function(key, index) {
                if( typeof this[key] === 'object' && this[key] !== null ) {

                    const strKey = key.toString().toLowerCase()

                    const isEqual = (
                        (
                            ( strKey == ':empty:' || strKey == ':notempty:' ) &&
                            (
                                ( strKey == ':empty:'    && ( strValue.length === 0 || strValue == '' || strValue === null ) ) ||
                                ( strKey == ':notempty:' && ( strValue.length > 0   || strValue ) )
                            )
                        ) ||
                        ( strValue == strKey )
                    )

                    if( isEqual ) {
                        thisObj.toggleFields( 'show', block, this[key].showOnEqual ?? [], 'showOnEqual' )
                        thisObj.toggleFields( 'hide', block, this[key].hideOnEqual ?? [], 'hideOnEqual' )
                    } else {
                        thisObj.toggleFields( 'show', block, this[key].showOnUnequal ?? [], 'showOnUnequal' )
                        thisObj.toggleFields( 'hide', block, this[key].hideOnUnequal ?? [], 'hideOnUnequal' )
                    }
                }
            }, conditions);
        },

        toggleFields( onoff = 'show', block, fields, method = '' ) {
            fields = fields.isArray ? fields : typeof fields == 'object' ? Object.values( fields ) : [fields]

            value = this.currentValue
            cond  = this.currentCondition

            fields.forEach(function (item, index) {
                if( toggleMe = block.querySelector(`.field[data-attribute="${item}"]`) ) {
                    ( onoff == 'hide' )
                        ? toggleMe.classList.add('matrixConditionals--hidden' )
                        : toggleMe.classList.remove('matrixConditionals--hidden' )

                    if( this.debug ) {
                        console.log( `applying "${value}" for rule matching: ${cond}\n  ${method}: ${item}   (${onoff})`)
                    }
                }
            });
        },

        testField( input, useValue = null, firstRun = false ) {

            const type      = input.getAttribute('type')     ?? null
            const tabindex  = input.getAttribute('tabindex') ?? null
            const classname = input.getAttribute('class')    ?? null
            const tagname   = input.tagName                  ?? null

            if( type == 'text' && tabindex == -1 ) {
                return
            }

            if( type == 'file' ) {
                return
            }

            if( type == 'hidden' && ! input.nextElementSibling.classList.contains('elementselect') ) {
                return
            }

            if( classname && classname.includes('redactor') ) {
                var textarea = input.parentNode.querySelector('textarea') ?? null
                if( textarea ) {
                    const div = document.createElement("div");
                    div.innerHTML = $R( '#' + textarea.id ?? null, 'source.getCode' );
                    useValue = div.textContent || div.innerText || null;
                }
            }

            var   value  = useValue ?? input.value ?? null
            const field  = input.closest('.field[data-type]:not([data-type=""])') ?? null
            const block  = field ? field.closest('.matrixblock[data-type]:not([data-type=""]):not(.superTableMatrix)') : null
            const mf     = block ? block.closest( '.matrix-field' ) : null
            const matrix = mf ? mf.closest('.field[data-type]:not([data-type=""])') : null

            if( !field || !block || !matrix ) {
                return
            }

            // find ONLY the first matching condition
            var conditions = this.findMatchingConditional(
                value,
                field.dataset.attribute,
                block.dataset.type,
                matrix.dataset.attribute
            )

            // evaluate checkboxes individually, instead of as a group
            if( type == 'checkbox' ) {
                var checkValue = this.decodeBase64(input.value)
                if( match = conditions[checkValue] ) {
                    conditions = {}
                    conditions[checkValue] = match
                } else {
                    conditions = null
                }
            }

            if( conditions ) {

                // check and see if we're inside a super table, and if so,
                // isolate the block context to the super table row instead
                if( input.closest('.superTableMatrix') ?? null ) {
                    if( ! firstRun ) {
                        this.evaluateConditions( input.closest('.superTableMatrix'), value, conditions )
                    }
                } else {
                    this.evaluateConditions( block, value, conditions )
                }
            }
        },

        setLoadState( inputs ) {
            var rGroups = []
            inputs.forEach((input) => {
                // evaluates radios as a group, instead of individual <inputs>
                if( input.getAttribute('type') == 'radio' ) {
                    const groupName = input.getAttribute('name')
                    if( rGroups[groupName] ?? null ) {
                        return
                    }
                    rGroups[groupName] = true

                    const checked    = document.querySelector(`input[name="${groupName}"]:checked`)
                    const groupValue = checked ? checked.value : ''

                    this.testField( input, groupValue )

                // evaluate checkbox value only if checked
                } else if( input.getAttribute('type') == 'checkbox' ) {
                    this.testField( input, input.checked ? input.value : '' )
                } else if( input.getAttribute('type') == 'select-one' ) {
                    // do nothing, this is as dummy field for selectize
                } else {
                    this.testField( input, null, firstRun = true )
                }
            });
        },

        watchForChildren( parents ) {
            parents.forEach((input) => {
                this.childCountObserver.observe(input, {
                    childList: true
                });

                // test for the first time
                const childCount = input.childElementCount ?? null
                const parentID   = input.parentElement.id ?? null
                const parentElem = document.querySelector( `#${parentID}`)
                if( parentElem ) this.testField( parentElem, ( childCount > 0 ) ? childCount : '' )
            });
        },

        // create an observer that watches selectize containers and waits for it to finish
        // initializing before we create a new observer to watch the value of the <select>
        waitForSelectizeInit( parents ) {
            parents.forEach((selectizeContainer) => {
                new MutationObserver(function(mutations) {
                    Craft.MatrixConditionals.createSelectizeObserver(
                        mutations[0].target.querySelector('select.selectized') ?? null
                    )
                }).observe( selectizeContainer, { childList: true } )
            });
        },

        // what to do when we detect a new selectize field
        createSelectizeObserver( newSelectizeField ) {
            if( newSelectizeField ) {
                new MutationObserver(function(mutations) {
                    if( mutations[0].target ) Craft.MatrixConditionals.testField( mutations[0].target )
                }).observe(
                    newSelectizeField, { childList: true }
                )
            }
        },

        init(debug = false, config) {

            this.config = config
            this.debug  = ( debug )

            // add listeners to input fields (text,radio,checkbox)
            document.addEventListener('input', (event) => {
                if( event.target.type == 'checkbox' ) {
                    this.testField( event.target, event.target.checked ? event.target.value : '' )
                } else {
                    this.testField( event.target )
                }
            }, false);


            // find existing selectize fields and create listeners
            existingSelectizeFields = document.querySelectorAll('.matrix.matrix-field .blocks select.selectized')
            existingSelectizeFields.forEach((field) => {
                Craft.MatrixConditionals.createSelectizeObserver( field )
            });

            this.hiddenInputObserver = new MutationObserver(function(mutations) {
                const fieldName = mutations[0].target.name ?? null
                const inputField = document.querySelector( `input[name="${fieldName}"]`)
                if( inputField ) Craft.MatrixConditionals.testField( inputField )
            });

            // find input fields like entries and assets that allow for adding one or more items to a list
            this.childCountObserver = new MutationObserver(function(mutations) {
                const childCount = mutations[0].target.childElementCount ?? null
                const parentID   = mutations[0].target.parentElement.id ?? null
                const parentElem = document.querySelector( `#${parentID}`)
                if( parentElem ) Craft.MatrixConditionals.testField( parentElem, ( childCount > 0 ) ? childCount : '' )
            });

            // find hidden inputs used in lightswitch fields
            hiddenInputs = document.querySelectorAll('.matrix.matrix-field .blocks .lightswitch-container + input[type="hidden"]')
            hiddenInputs.forEach((input) => {
                this.hiddenInputObserver.observe(input, {
                    attributes: true
                });
            });

            // find div.elements used for asset / entries and table.body elements used for tables
            this.watchForChildren( document.querySelectorAll(`
                .matrix.matrix-field>.blocks fieldset.field div.elementselect div.elements,
                .matrix.matrix-field>.blocks div.matrixLayoutContainer div.elementselect div.elements,
                .matrix.matrix-field>.blocks fieldset.field table.editable tbody
            `) )

            // find all matrix block fields on the page on load, and test each of them against possible conditions
            const inputs = document.querySelectorAll('.matrix-field .field input,.matrix-field .field select,.matrix-field .field textarea');
            this.setLoadState( inputs )


            // create a mutation observer to watch for when new blocks get added
            const blockObserver = new MutationObserver(function(mutations) {
                const addedNode = mutations[0].addedNodes[0] ?? null;
                if( addedNode ) {
                    const dataid = addedNode.dataset.id ?? ''

                    // find all inputs and select fields in the new block and test them
                    const inputs = document.querySelectorAll(`.matrixblock[data-id="${dataid}"] input,.matrixblock[data-id="${dataid}"] select`);
                    Craft.MatrixConditionals.setLoadState( inputs )

                    // find any hidden inputs in the new block and observe them for attribute change
                    const newHiddenInputs = document.querySelectorAll(`.matrixblock[data-id="${dataid}"] .field .lightswitch-inner-container input[type="hidden"]`)
                    newHiddenInputs.forEach((input) => {
                        Craft.MatrixConditionals.hiddenInputObserver.observe(input, {
                            attributes: true
                        });
                    });

                    // find new selectize dropdown fields and watch them
                    Craft.MatrixConditionals.waitForSelectizeInit(
                        document.querySelectorAll(`.matrixblock[data-id="${dataid}"] .selectize.select`)
                    )

                    // find div.elements used for asset / entries and table.body elements used for tables
                    Craft.MatrixConditionals.watchForChildren( addedNode.querySelectorAll('fieldset.field div.elementselect div.elements' ) )
                    Craft.MatrixConditionals.watchForChildren( addedNode.querySelectorAll('fieldset.field table.editable tbody' ) )

                    // find all the nested super table fields within each matrix field on the page and observe it
                    supertableFields = addedNode.querySelectorAll('.superTableContainer .matrixLayoutContainer')
                    supertableFields.forEach((supertblField) => {
                        supertableObserver.observe(supertblField, {
                            childList: true
                        });
                    });
                }
            });

            // find all the block fields for each matrix field on the page and observe it
            blockFields = document.querySelectorAll('.matrix.matrix-field>.blocks')
            blockFields.forEach((blockField) => {
                blockObserver.observe(blockField, {
                    childList: true
                });
            });


            // create a mutation observer to watch for when new rows are added to a supertable
            const supertableObserver = new MutationObserver(function(mutations) {
                const addedNode = mutations[0].addedNodes[0] ?? null;
                if( addedNode ) {

                    // find div.elements used for asset / entries and table.body elements used for tables
                    Craft.MatrixConditionals.watchForChildren(
                        addedNode.querySelectorAll( 'div.elementselect div.elements' )
                    )

                }
            });

            // find all the nested super table fields within each matrix field on the page and observe it
            supertableFields = document.querySelectorAll('.superTableContainer .matrixLayoutContainer')
            supertableFields.forEach((supertblField) => {
                supertableObserver.observe(supertblField, {
                    childList: true
                });
            });
        }
    };
}

document.addEventListener('DOMContentLoaded', (event) => {
    Craft.MatrixConditionals.init( debug = true, matrixConditionalsConfig )
});

{% endjs %}

{% css %}
    .matrixConditionals--hidden {
        {# height : 1px !important;
        max-height : 1px !important;
        overflow: hidden !important;
        opacity: 0 !important;
        margin-bottom: 0 !important; #}
        display: none;
    }

    #content :not(.meta) > .flex-fields > .matrixConditionals--hidden {
        margin-bottom: 0 !important;
    }
{% endcss %}