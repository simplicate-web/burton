{## Conditional Matrix Fields for Craft CMS 4.x
 ------------------------------------------------------------------------------------ ##
    https://github.com/simplicateca/craft4-matrix-conditionals
    Steve Comrie <steve@simplicate.ca>
 ------------------------------------------------------------------------------------ ##}

{% js %}

// Sample configuration
// read more here: https://github.com/simplicate-web/craft4-matrix-conditionals#configuration
// ---------------------------------------------------------------
var matrixConditionalsConfig = {

    // text block type
    '*.text.variant': {

        'single': {
            showAll: ['text'],
            hideAll: ['text2','bits','summary'],
        },

        'secondaryReveal': {
            showAll: ['text', 'text2'],
            hideAll: ['bits','summary'],
        },

        'sideBySide': {
            showAll: ['text', 'text2'],
            hideAll: ['bits','summary'],
        },

        'callout': {
            showAll: ['text','bits','summary'],
            hideAll: ['text2'],
        }
    },

    // image block type
    '*.image.source': {

        'images': {
            showAll: 'images',
            hideAll: 'collections',
        },

        'collect': {
            showAll: 'collections',
            hideAll: 'images',
        }
    },

    // media block type
    '*.media.source': {

        'assets': {
            showAll: ['assets'],
            hideAll: ['external','code','collections'],
        },

        'external': {
            showAll: ['external'],
            hideAll: ['assets','code','collections'],
        },

        'collect': {
            showAll: ['collections'],
            hideAll: ['assets','code','external'],
        },

        'code': {
            showAll: ['code'],
            hideAll: ['assets','collections','external'],
        }
    },

    // collections block type
    '*.collection.source':
    {
        'entries': {
            showAll: ['entries'],
            hideAll: ['collections','items'],
        },

        'collect': {
            showAll: ['collections'],
            hideAll: ['entries','items'],
        },

        'items': {
            showAll: ['items'],
            hideAll: ['collections','entries'],
        },
    },


    // collections variant
    '*.collection.variant':
    {
        'search': {
            hideAll: ['source'],
            notShowAll: ['source'],
        }
    },


    // action block type
    '*.action.variant':
    {
        'search': {
            showAll: ['collections'],
            hideAll: ['component', 'form'],
        },

        'form': {
            showAll: ['form'],
            hideAll: ['collections', 'component'],
        },

        'component': {
            showAll: ['component'],
            hideAll: ['collections', 'form'],
        }
    }
}


if( typeof Craft.MatrixConditionals === 'undefined' ) {
    Craft.MatrixConditionals = {

        findMatchingConditional(value, field, block, matrix) {
            this.currentValue = this.cleanValue( value )

            if( $fullMatch = this.findFieldCondition(`${matrix}.${block}.${field}`) )
                return $fullMatch

            if( $anyMatrixMatch = this.findFieldCondition(`*.${block}.${field}`) )
                return $anyMatrixMatch

            {# if( $anyBlockMatch = this.findFieldCondition(`${matrix}.*.${field}`) )
                return $anyBlockMatch #}

            {# if( $anyField = this.findFieldCondition(`*.*.${field}`) )
                return $anyField #}
        },

        findFieldCondition( condition ) {
            this.currentCondition = condition
            return this.config[condition] ?? null
        },

        cleanValue(value) {
            if( ! value ?? null ) { return '' }
            var strValue = value.toString().trim().toLowerCase()
            if( strValue.startsWith('base64:') ) {
                strValue = this.decodeBase64( value ).toLowerCase();
            }

            return strValue
        },

        decodeBase64(value) {
            if( ! value ?? null ) { return '' }
            return atob(value.toString().trim().replace('base64:', ''))
        },

        evaluateConditions( block, value, conditions ) {
            const thisObj  = this
            const strValue = this.cleanValue( value )

            Object.keys(conditions).forEach(function(key, index) {
                if( typeof this[key] === 'object' && this[key] !== null ) {

                    const strKey = key.toString().toLowerCase()

                    const isEqual = (
                        (
                            ( strKey == ':empty:' || strKey == ':notempty:' ) &&
                            (
                                ( strKey == ':empty:'    && ( strValue.length === 0 || strValue == '' || strValue === null ) ) ||
                                ( strKey == ':notempty:' && ( strValue.length > 0   || strValue ) )
                            )
                        ) ||
                        ( strValue == strKey )
                    )

                    if( ! isEqual ) {
                        thisObj.toggleFields( 'hideAll', block, this[key].notHideAll ?? [] )
                        thisObj.toggleFields( 'showAll', block, this[key].notShowAll ?? [] )
                    }

                    if( isEqual ) {
                        thisObj.toggleFields( 'hideAll', block, this[key].hideAll ?? [] )
                        thisObj.toggleFields( 'showAll', block, this[key].showAll ?? [] )

                        if( this[key].showOnlyOne ?? null ) {
                            thisObj.toggleFields( 'showOnlyOne', block, this[key].showOnlyOne )
                        }
                    }

                    {# else {
                        notHideAll
                        thisObj.toggleFields( 'show', block, this[key].showOnUnequal ?? [], 'showOnUnequal' )
                        thisObj.toggleFields( 'hide', block, this[key].hideOnUnequal ?? [], 'hideOnUnequal' )
                    } #}
                }
            }, conditions);
        },

        toggleFields( setting = 'showAll', block, fields, method = '' ) {
            fields = fields.isArray ? fields : typeof fields == 'object' ? Object.values( fields ) : [fields]

            value = this.currentValue
            cond  = this.currentCondition

            firstMatch   = null
            foundVisible = false

            fields.forEach(function (item, index) {
                if( matchingField = block.querySelector(`.field[data-attribute="${item}"]`) ) {

                    if( setting == 'showOnlyOne' ) {
                        firstMatch = firstMatch ?? matchingField
                        if( foundVisible ) {
                            matchingField.classList.add('matrixConditionals--hidden' )
                        } else {
                            if( !matchingField.classList.contains('matrixConditionals--hidden') ) {
                                foundVisible = true
                            }
                        }
                    }

                    if( setting == 'showAll' ) {
                        matchingField.classList.remove('matrixConditionals--hidden' )
                        if( this.debug ) {
                            console.log( `applying "${value}" for rule matching: ${cond}\n  ${setting}: ${item}`)
                        }
                    }

                    if( setting == 'hideAll' ) {
                        matchingField.classList.add('matrixConditionals--hidden' )
                        if( this.debug ) {
                            console.log( `applying "${value}" for rule matching: ${cond}\n  ${setting}: ${item}`)
                        }
                    }
                }
            });

            if( setting == 'showOnlyOne' && ! foundVisible ) {
                firstMatch.classList.remove('matrixConditionals--hidden' )

                if( this.debug ) {
                    console.log( `applying "${value}" for rule matching: ${cond}\n  ${setting}`)
                }
            }
        },

        testField( input, useValue = null, firstRun = false ) {

            const type      = input.getAttribute('type')     ?? null
            const tabindex  = input.getAttribute('tabindex') ?? null
            const classname = input.getAttribute('class')    ?? null
            const tagname   = input.tagName                  ?? null
            const nextsib   = input.nextElementSibling       ?? null

            if( !classname || ( classname && classname.includes('spf__input') ) ) {
                return
            }

            if( type == 'text' && tabindex == -1 ) {
                return
            }

            if( type == 'file' ) {
                return
            }

            if( type == 'hidden' && ( nextsib && ! nextsib.classList.contains('elementselect') ) ) {
                return
            }

            if( classname && classname.includes('redactor') ) {
                var textarea = input.parentNode.querySelector('textarea') ?? null
                if( textarea ) {
                    const div = document.createElement("div");
                    div.innerHTML = $R( '#' + textarea.id ?? null, 'source.getCode' );
                    useValue = div.textContent || div.innerText || null;
                }
            }

            var   value  = useValue ?? input.value ?? null
            const field  = input.closest('.field[data-type]:not([data-type=""])') ?? null
            const block  = field ? field.closest('.matrixblock[data-type]:not([data-type=""]):not(.superTableMatrix)') : null
            const mf     = block ? block.closest( '.matrix-field' ) : null
            const matrix = mf ? mf.closest('.field[data-type]:not([data-type=""])') : null

            if( !field || !block || !matrix ) {
                return
            }

            // find ONLY the first matching condition
            var conditions = this.findMatchingConditional(
                value,
                field.dataset.attribute,
                block.dataset.type,
                matrix.dataset.attribute
            )

            // evaluate checkboxes individually, instead of as a group
            if( type == 'checkbox' ) {
                var checkValue = this.decodeBase64(input.value)
                if( match = conditions[checkValue] ) {
                    conditions = {}
                    conditions[checkValue] = match
                } else {
                    conditions = null
                }
            }

            if( conditions ) {

                // check and see if we're inside a super table, and if so,
                // isolate the block context to the super table row instead
                if( input.closest('.superTableMatrix') ?? null ) {
                    if( ! firstRun ) {
                        this.evaluateConditions( input.closest('.superTableMatrix'), value, conditions )
                    }
                } else {
                    this.evaluateConditions( block, value, conditions )
                }
            }
        },

        setLoadState( inputs )
        {
            var rGroups = []
            inputs.forEach((input) => {

                if( input.getAttribute('id') ) {

                    if( input.getAttribute('id').includes('selectize') && input.tagName != 'SELECT' ) {
                        return
                    }

                    if( input.getAttribute('type') ) {
                        // evaluates radios as a group, instead of individual <inputs>
                        if( input.getAttribute('type') == 'radio' ) {
                            const groupName = input.getAttribute('name')
                            if( rGroups[groupName] ?? null ) {
                                return
                            }
                            rGroups[groupName] = true

                            const checked    = document.querySelector(`input[name="${groupName}"]:checked`)
                            const groupValue = checked ? checked.value : ''

                            this.testField( input, groupValue )

                        // evaluate checkbox value only if checked
                        } else if( input.getAttribute('type') == 'checkbox' ) {
                            this.testField( input, input.checked ? input.value : '' )
                        }

                        return
                    }

                    this.testField( input, null, firstRun = true )
                }
            });
        },

        watchForChildren( parents ) {
            parents.forEach((input) => {
                this.childCountObserver.observe(input, {
                    childList: true
                });

                // test for the first time
                const childCount = input.childElementCount ?? null
                const parentID   = input.parentElement.id ?? null
                const parentElem = document.querySelector( `#${parentID}`)
                if( parentElem ) this.testField( parentElem, ( childCount > 0 ) ? childCount : '' )
            });
        },

        // create an observer that watches selectize containers and waits for it to finish
        // initializing before we create a new observer to watch the value of the <select>
        waitForSelectizeInit( parents ) {
            parents.forEach((selectizeContainer) => {
                new MutationObserver(function(mutations) {
                    Craft.MatrixConditionals.createSelectizeObserver(
                        mutations[0].target.querySelector('select.selectized') ?? null
                    )
                }).observe( selectizeContainer, { childList: true } )
            });
        },

        // what to do when we detect a new selectize field
        createSelectizeObserver( newSelectizeField ) {
            if( newSelectizeField ) {
                new MutationObserver(function(mutations) {
                    if( mutations[0].target ) Craft.MatrixConditionals.testField( mutations[0].target )
                }).observe(
                    newSelectizeField, { childList: true }
                )
            }
        },

        init(debug = false, config) {

            this.config = config
            this.debug  = ( debug )

            // add listeners to input fields (text,radio,checkbox)
            document.addEventListener('input', (event) => {
                if( event.target.type == 'checkbox' ) {
                    this.testField( event.target, event.target.checked ? event.target.value : '' )
                } else {
                    this.testField( event.target )
                }
            }, false);


            // find existing selectize fields and create listeners
            existingSelectizeFields = document.querySelectorAll('.matrix.matrix-field .blocks select.selectized')
            existingSelectizeFields.forEach((field) => {
                Craft.MatrixConditionals.createSelectizeObserver( field )
            });

            this.hiddenInputObserver = new MutationObserver(function(mutations) {
                const fieldName = mutations[0].target.name ?? null
                const inputField = document.querySelector( `input[name="${fieldName}"]`)
                if( inputField ) Craft.MatrixConditionals.testField( inputField )
            });

            // find input fields like entries and assets that allow for adding one or more items to a list
            this.childCountObserver = new MutationObserver(function(mutations) {
                const childCount = mutations[0].target.childElementCount ?? null
                const parentID   = mutations[0].target.parentElement.id ?? null
                const parentElem = document.querySelector( `#${parentID}`)
                if( parentElem ) Craft.MatrixConditionals.testField( parentElem, ( childCount > 0 ) ? childCount : '' )
            });

            // find hidden inputs used in lightswitch fields
            hiddenInputs = document.querySelectorAll('.matrix.matrix-field .blocks .lightswitch-container + input[type="hidden"]')
            hiddenInputs.forEach((input) => {
                this.hiddenInputObserver.observe(input, {
                    attributes: true
                });
            });

            // find div.elements used for asset / entries and table.body elements used for tables
            this.watchForChildren( document.querySelectorAll(`
                .matrix.matrix-field>.blocks fieldset.field div.elementselect div.elements,
                .matrix.matrix-field>.blocks div.matrixLayoutContainer div.elementselect div.elements,
                .matrix.matrix-field>.blocks fieldset.field table.editable tbody
            `) )

            // find all matrix block fields on the page on load, and test each of them against possible conditions
            const inputs = document.querySelectorAll('.matrix-field .field input,.matrix-field .field select,.matrix-field .field textarea');
            this.setLoadState( inputs )


            // create a mutation observer to watch for when new blocks get added
            const blockObserver = new MutationObserver(function(mutations) {
                const addedNode = mutations[0].addedNodes[0] ?? null;
                if( addedNode ) {
                    const dataid = addedNode.dataset.id ?? ''

                    // find any hidden inputs in the new block and observe them for attribute change
                    const newHiddenInputs = document.querySelectorAll(`.matrixblock[data-id="${dataid}"] .field .lightswitch-inner-container input[type="hidden"]`)
                    newHiddenInputs.forEach((input) => {
                        Craft.MatrixConditionals.hiddenInputObserver.observe(input, {
                            attributes: true
                        });
                    });

                    // find new selectize dropdown fields and watch them
                    Craft.MatrixConditionals.waitForSelectizeInit(
                        document.querySelectorAll(`.matrixblock[data-id="${dataid}"] .selectize.select`)
                    )

                    // find div.elements used for asset / entries and table.body elements used for tables
                    Craft.MatrixConditionals.watchForChildren( addedNode.querySelectorAll('fieldset.field div.elementselect div.elements' ) )
                    Craft.MatrixConditionals.watchForChildren( addedNode.querySelectorAll('fieldset.field table.editable tbody' ) )

                    // find all the nested super table fields within each matrix field on the page and observe it
                    supertableFields = addedNode.querySelectorAll('.superTableContainer .matrixLayoutContainer')
                    supertableFields.forEach((supertblField) => {
                        supertableObserver.observe(supertblField, {
                            childList: true
                        });
                    });

                    // find all inputs and select fields in the new block and test them
                    const inputs = document.querySelectorAll(`.matrixblock[data-id="${dataid}"] input,.matrixblock[data-id="${dataid}"] select`);

                    // this didn't use to need a delay, but now it does now.
                    // I don't like it, but this code hopefully won't live past Craft 4 so ....
                    setTimeout(() => {
                        Craft.MatrixConditionals.setLoadState( inputs )
                    }, 250 );
                }
            });

            // find all the block fields for each matrix field on the page and observe it
            blockFields = document.querySelectorAll('.matrix.matrix-field>.blocks')
            blockFields.forEach((blockField) => {
                blockObserver.observe(blockField, {
                    childList: true
                });
            });


            // create a mutation observer to watch for when new rows are added to a supertable
            const supertableObserver = new MutationObserver(function(mutations) {
                const addedNode = mutations[0].addedNodes[0] ?? null;
                if( addedNode ) {

                    // find div.elements used for asset / entries and table.body elements used for tables
                    Craft.MatrixConditionals.watchForChildren(
                        addedNode.querySelectorAll( 'div.elementselect div.elements' )
                    )

                }
            });

            // find all the nested super table fields within each matrix field on the page and observe it
            supertableFields = document.querySelectorAll('.superTableContainer .matrixLayoutContainer')
            supertableFields.forEach((supertblField) => {
                supertableObserver.observe(supertblField, {
                    childList: true
                });
            });
        }
    };
}

if( typeof Craft.BurtonMatrixTweaks === 'undefined' ) {
    Craft.BurtonMatrixTweaks = {

        init() {

            // create a mutation observer to watch for when new blocks get added to a matrix field
            const blockObserver = new MutationObserver(function(mutations) {
                const addedNode = mutations[0].addedNodes[0] ?? null;
                if( addedNode ) {
                    layoutFields = addedNode.querySelectorAll('#content div.matrix-field .flex-fields div[data-attribute="layout"]')
                    layoutFields.forEach((layoutField) => {
                        setTimeout(() => {
                            layoutField.insertAdjacentHTML( 'beforebegin', '<span class="flex-break"></span>' );
                        }, 1000);
                    });
                }
            });

            // find all the block fields for each matrix field on the page and observe it
            blockFields = document.querySelectorAll('.matrix.matrix-field>.blocks')
            blockFields.forEach((blockField) => {
                blockObserver.observe(blockField, {
                    childList: true
                });
            });

            layoutFields = document.querySelectorAll('#content div.matrix-field .flex-fields div[data-attribute="layout"]')
            layoutFields.forEach( (layoutField) => {
                setTimeout(() => {
                    layoutField.insertAdjacentHTML( 'beforebegin', '<span class="flex-break"></span>' );
                }, 1000);
            });
        }
    };
}

document.addEventListener('DOMContentLoaded', (event) => {
    Craft.MatrixConditionals.init( debug = true, matrixConditionalsConfig );
    {# Craft.BurtonMatrixTweaks.init(); #}
});

{% endjs %}

{% css %}
    .matrixConditionals--hidden {
        display: none;
    }

    #content :not(.meta) > .flex-fields > .matrixConditionals--hidden {
        margin-bottom: 0 !important;
    }
{% endcss %}

<!--
    DO NOT DELETE THIS COMMENT
    Craft CMS gets angry if there aren't any "HTML elements" in a template UI file.
    And you wouldn't like Craft CMS when it's angry.
-->